=====
REst
=====
https://spring.io/guides/gs/rest-service/
https://www.javacodegeeks.com/2012/11/spring-mvc-rest-calls-with-ajax.html
========
Swagger
========


TODO
	-Unique Key
	-
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.4.0.RELEASE</version>
  </parent>

	
	    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>4.3.2.RELEASE</version>
    </dependency>
            <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <optional>true</optional>
        </dependency>
            <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>compile</scope>
    </dependency>
    <dependency>
      <groupId>com.jayway.jsonpath</groupId>
      <artifactId>json-path</artifactId>
      <scope>compile</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <scope>compile</scope>
    </dependency>
    
    
        @ApiOperation(value = "analyze", nickname = "analyzeRDF")
    @ApiImplicitParams({
        @ApiImplicitParam(name = "id", value = "Key", required = true, dataType = "string", paramType = "path", defaultValue="film_runtime_100"),
      })
    @RequestMapping(value="/analyze", method=RequestMethod.GET, produces={"application/json"})
    public @ResponseBody String analyzeRDF(@RequestParam(value="id",defaultValue="film_runtime_100")String id,
    									   @RequestParam(value="property", defaultValue="properties") String property) {
    	
    	RDFAnalyze ra = new RDFAnalyze("./RDF_DATA/"+id);
 
    	if(property.equals("properties")) {
    		
    		ArrayList<String> result = ra.possibleProperties();
    	
    		int size = result.size();
    	
    		String value = "\""+String.valueOf(size)+"\"";
    	
    		String content ="{ " ;
    	
    		for(int i = 0; i < size; i++) {
    			content += "\""+i+"\" : \""+result.get(i)+"\"";
    			if(i < (size-1)) {
    				content += " , ";
    			} else {
    				content += " }";
    			}
    		}
    	
    		return	 "{ \"type\" : \"properties\" , \"value\" : "+value+" , \"content\" : "+content+" }";

    	} else {
    	
    		String[][] result = ra.countDatatype(property);
    		
    		int size = result.length;
        	
    		String value = "\""+String.valueOf(size)+"\"";
    	
    		String content ="{ " ;
    		
    		for(int i = 0; i < size; i++) {
    			content += "\""+i+"\" : { \"name\" : \""+result[i][0]+"\" , \"value\" : \""+result[i][1]+"\" }";
    			if(i < (size-1)) {
    				content += " , ";
    			} else {
    				content += " }";
    			}
    		}
    	
    		return "{ \"type\" : \""+property+"\" , \"value\" : "+value+" , \"content\" : "+content+" }";
    	}
    	
    	
    	
  ####
  
  		if(query.isSelectType()) {
			this.uniqueQuery = buildConQuery(query);
		} else if(query.isConstructType()) {
			this.uniqueQuery = query;
		}
	}
	
/*
 * Building a construct query from a select query
 * TODO [Construct,Where,Limit,Offset] finished [optional] left 
 * 
 * @return 			construct query
 */	
	public static Query buildConQuery(Query query) {
		
		String conquery = "";
		
			
			String partOffset = "";
			String partLimit = "";
		
			String partWhere = query.getQueryPattern().toString();
		
			if(query.hasOffset()) {
				partOffset = "Offset "+String.valueOf(query.getOffset());
			}
			if(query.hasLimit()){
				partLimit = "Limit "+String.valueOf(query.getLimit());
			}
		
			conquery = "Construct "+partWhere+" Where "+partWhere+" "+partOffset+" "+partLimit;
		
		return QueryFactory.create(conquery);
	}

/*
 * Check select, construct, ask, describe
 */
	private static String queryType(String queryStr) {
		Query query = QueryFactory.create(queryStr);
		
		String type ="";
		
		if(query.isAskType()) 		type = "ASK";
		if(query.isConstructType()) type = "CONSTRUCT";
		if(query.isDescribeType())	type = "DESCRIBE";
		if(query.isSelectType())	type = "SELECT";
		
		return type;
	}
	
/*
 * 
 */
	public Query getQuery() {
		return this.uniqueQuery;
	}*/
}	

####

    
/**TEST**************************************************************************************************************
    
    @RequestMapping(value="/test", method=RequestMethod.GET, produces={"application/json"})
    public @ResponseBody String testrest(@RequestParam(value="param1", defaultValue="param1")String param1,
    									 @RequestParam(value="param2", defaultValue="param2")String param2,
    									 HttpServletResponse  response) {
    	
    	
    	
    	return "{\"name\":\"unknown\", \"age\":-1 , \"field\" : {\"1\" : \"a\" , \"2\" : \"b\"}}";
    	
    }

    @RequestMapping(value="/{time}", method = RequestMethod.GET)
    public @ResponseBody MyData getMyData(
            @PathVariable long time) {

        return new MyData(time, "REST GET Call !!!");
    }

    @RequestMapping(method = RequestMethod.PUT)
    public @ResponseBody MyData putMyData(
            @RequestBody MyData md) {

        return md;
    }

    @RequestMapping(method = RequestMethod.POST)
    public @ResponseBody MyData postMyData() {

    	return new MyData(System.currentTimeMillis(),
            "REST POST Call !!!");
    }

    @RequestMapping(value="/{time}", method = RequestMethod.DELETE)
    public @ResponseBody MyData deleteMyData(
            @PathVariable long time) {

        return new MyData(time, "REST DELETE Call !!!");
    }*/